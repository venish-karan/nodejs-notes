# Module.exports VS exports

In javascript when you create a object and that object is referenced my another variable and when you attach a new object to it,
object 1 loses its reference now object 2 points to new object

const obj1 = {
  name: "P"
}

let obj2 = obj1;
obj2 = {
  name: "Q"
}

# Understanding `module.exports` vs `exports` in Node.js

In Node.js modules, `module.exports` and `exports` are both used to export functionality, but they work differently under the hood:

- **`module.exports`** is the actual object that Node.js returns when a module is required.
- **`exports`** is initially just a reference pointing to `module.exports`.

## How It Works

When you add properties like this:

exports.myFunction = function() { ... };

text

You are modifying the same object that `module.exports` points to, so the export works as expected.

But if you assign a new object to `exports` directly, such as:

exports = {};

text

You break the connection between `exports` and `module.exports`. Now `exports` refers to a new object, but `module.exports` still points to the original export object. Since Node.js returns `module.exports` when requiring the module, the new object assigned to `exports` is ignored.

## Why the Reference Is Lost

- Assigning a new object to `exports` breaks its link with `module.exports`.
- `module.exports` remains unchanged and is what Node.js exports.
- The new `exports` object is discarded because it is no longer connected.

## Correct Exporting Method

To export a new object or replace what the module exports, assign the object to `module.exports` directly:

module.exports = {};

text

This updates the actual exported object.

---

## Key Takeaways

- `exports` is just a shorthand alias for `module.exports` at the start.
- Overwriting `exports` with a new object breaks the link with `module.exports`.
- Node.js only exports whatever `module.exports` references.
- Use `module.exports = ...` when exporting a completely new object or value.

This explains why assigning a new object to `exports` “loses” the export reference—it stops pointing to the exported object, so Node.js ignores it.
